# 4.（必做）根据上述自己对于 1 和 2 的演示，写一段对于不同 GC 和堆内存的总结，提交到 GitHub

## 关于GC和堆的总结
java之所以要GC，是因为内存资源的稀缺性，为了更好的管理和使用内存，才有了垃圾回收。在java中把没有任何引用指向的对象
称为垃圾，如何找到垃圾？有两种方法：一种是引用计数法，一种是根可达法。引用计数无法解决A-B-A的问题，会造成内存泄漏，
因此目前JVM采用根可达法来标记哪些是存活对象，哪些是垃圾。哪些是根呢？也就是GC Roots，常见的GC Roots有当前活动的线程，
正在执行的方法里的参数和局部变量，类的静态变量，JNI对象等等。基于分代假设(即大部分创建的对象朝生夕死，存活周期短，存
活周期长的一般不会马上被回收),产生不同的垃圾回收器，总结来看，主要使用了3种垃圾回收算法，分别是：
复制算法：复制存活对象到另一个内存空间，简单快速，适用于生命周期短且对象数量少，缺点是浪费空间。
标记清除：标记存活对象，其他的为垃圾，清除垃圾即可，不会造成内存浪费，但是会造成内存碎片。
标记整理：清除垃圾后整理存活对象移动到内存区域的一端对齐，效率比标记清除慢，但是内存空间利用率高。
常见的垃圾回收器有：串行GC，并行GC,CMS,G1 GC,ZGC,Shenandoah GC。 那么，不同jdk版本的GC垃圾回收器是什么？
在jdk6，7，8，默认是并行垃圾回收器，即：ParallelGC,从jdk9开始默认的的垃圾回收器是G1 GC。并行GC的设计初衷是
为了提高系统的吞吐量，从GC角度来说，大部分时间里都是业务代码在运行，这就造成了进行一次GC STW的时候较长，而如CMS的设
计目的是为了降低延迟，减少STW暂停时间，对于响应时间有严格要求的系统适合采用CMS。GC的主要区域就是堆，堆内存的布局分为
年轻代+老年代，非堆实际上也是堆，只不过不是垃圾回收的主要区域，在jdk8之前称为永久代或者方法区，jdk8之后称之为元空间，
属于堆外内存。年轻代和老年代的默认大小比例为1:2，年轻代有分为eden区和2个survivor区，默认大小比例为8:1:1，其中一个survivor区总是空的，
eden区满的时候会发生minor GC，对eden区进行垃圾回收。老年代满会发生major GC,对年轻代和老年代回收。年轻代多次（默认15）回收
仍存活的对象晋升到老年代中。关于默认最大堆是多少？如果系统物理内存大于等于192m，最大堆为物理内存的1/4,小于则为1/2,
为1024的倍数，不能低于2m，一般设置为可用物理内存的0.6~0.8。关于GC日志，java程序启动是配置参数java -XX:+PrintGCDetails -Xloggc:gc.log 
-XX:+PrintGCDetails -XX:+PrintGCDateStamps可以打印GC的详细日志信息，可以配置不同的垃圾回收器，如：
-XX:+UseSerialGC，-XX:+UseParallelGC，-XX:+UseConcMarkSweepGC，-XX:+UseG1GC等等。一般情况下，建议Xmx
和Xms配置的一样大，因为如果只是配置了Xms，那么在内存不足时会扩容，直到达到默认的最大堆内存，这样容易造成应用的抖动，
另外，最好关闭自适应参数，在查看GC日志的时候会发现，堆的内存大小和指定的大小有差异，这是因为JVM内部会根据实际情况
调整大小，所以最好关闭以免有出入。另外，垃圾回收的线程也要注意不能配置的过多，过多一是会和业务线程抢占CPU资源，二是
过多的线程上下文切换也会带来不小的开销。通过一次young GC我们可以看出有多少对象晋升到老年代，我们可以看到对象的分配速度
是怎么样的，可以看到对象的提升速度是怎么样的，以此来反映整个堆内存的使用变化趋势，为可能出现的问题未雨绸缪，尽早做
处理。GC日志我们还可以通过可视化或在线分析工具来处理分析，如GCEasy和GCViewer。